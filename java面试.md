**基础知识**：

**计算机基础**：操作系统、网络、数据库

**编程语言基础**：数据类型、装箱和拆箱、

​	编码技巧：递归控制、循环控制、边界控制

​	数据结构

​	树的遍历

​	面向对象思想：类与对象、接口与实现、继承与封装、不可变类型、泛型

​	设计模式：singleton、变继承为组合、对象如何创建

​	高级知识：并行计算、多线程、资源管理

**编程能力**：

### 操作系统：

进程vs线程：

process VS thread

进程：含有很多线程。每个进程的逻辑内存是相互独立的。

文件/网络句柄(handler):是所有进程所共有的。可以打开同一个文件或者抢同一个端口。

进程相当于一个容器，有很强的隔离性。TCP/IP

进程开销很大。



线程：是进程中的一部分。含有栈不是堆栈，每次函数调用都会把调用的额外函数和局部变量放在栈中。PC：programm Counter，存放下一条指令的执行地址。操作系统中真正运行的是一个一个的线程，而不是进程。进程只是一个容器。PC存放在内存中。TLS：是线程中所独有的一部分。



**存储**：硬盘=>内存=>CPU缓存(缓存分级)=>寄存器(离运算模块最近)

寻址空间：(逻辑内存)

​	32位：4G

​	64位：10^19Bytes

​	64位JVM:可以使用更大的内存，需要重新编译

​	每个进程都有自己的一块逻辑内存，逻辑内存与物理内存不存在关系，只与操作系统存在关系。

​	int n = * p ;    指针p => 逻辑内存，进程独立(2^32,或者2^64)

​	**逻辑内存**与**物理内存**和**虚拟内存**相对应。虚拟内存存在硬盘中。

​	虚拟内存存在分页，不用精确搜索，直接分页从虚拟内存放进物理内存。

​	将物理内存长久不用的东西交换到虚拟内存。

**进程间通信：**

1. 文件
2. Signal：linux常见。
3. 消息队列
4. 管道/命名管道
5. 共享内存
6. 同步机制，如信号量
7. Socket

### 网络

**数据链路层**

**网络层**

**传输层**

**应用层**

不可靠：丢包、重复包、乱序

不安全：中间人攻击、窃取信息、篡改

**滑动窗口**协议：解决不可靠问题，**Tcp协议**中使用。缓冲区。丢ACK。

ACk始终回不来，会有超时重传

**流量控制**、**拥塞控制**，**滑动窗口大小为0是合理**的(当用户来不及确认Ack的时候)。

一次传输是一个来回的时间。	

**TCP和滑动窗口的一些问题：**

TCP是连接的协议，目的是可靠的传输。流量控制和拥塞控制

滑动窗口的运行解决了：更好的利用带宽，流量控制

TCP协议的流量控制是通过滑动窗口来实现的。

TCP建立连接(三次握手)，TCP断开连接(四次挥手)：

* 网络是不可靠的任何包都有可能丢
* 遇见问题解决问题，不断迭代
* 能用就好
* ACK, SYN,FIN,FINAL_WAIT_1, TIME_WAIT,CLOSED





# 数据库部分

## 关系型数据库

* 基于关系代数理论，一范式、二范式、三范式、四范式、五范式
* 缺点：表结构不直观、实现复杂、速度慢
* 优点：健壮性高(仅仅针对一个节点而言的)、社区庞大

健壮性在于外键的约束性极强。

select * from table1， join t2 on condition





OSI互联参考模型(仅仅是描述概念，作为一个参考标准)

1. **物理层**：机械、电子、定时接口通信信道上的原始bit流传输
2. **数据链路层**：物理寻址、同时将原始比特流变为逻辑传输线路
3. **网络层**：控制子网的运行，如逻辑编址、分组传输、路由选择
4. **传输层**：主机间的数据传输，osi中最重要，TCP/UDP
5. **会话层**：建立和管理应用程序
6. **表示层**：信息的语法语义以及他们的关联，如加密、解密、转换翻译、压缩解压缩
7. **应用层**：HTTP

先自上而下，后自下而上处理数据头部

发送进程： 应用层 => 表示层 => 会话层(前三层是组织数据)=>传输层(分段)=>网络层(分组，数据报)=>数据链路层(帧)=>物理层(比特)

接收进程: 	物理层=>数据链路层=>网络层=>传输层=>会话层=>表示层=>应用层

TCP/IP概念层模型: 只包含四层:应用层，传输层、网络层、链路层

* 应用层： 
  * 应用层：文件传输、电子邮件、文件服务、虚拟终端
  * 表示层：数据格式化、代码转换、数据加密
  * 会话层：解除或建立与别的接点的联系
* 传输层：提供端对端的接口
* 网络层：为数据包选择路由
* 链路层：
  * 数据链路层：传输有地址的帧以及错误检测功能
  * 物理层：以二进制数据形式在物理媒体上传输数据

HTTP数据 => Http报文 => TCP首部=>IP首部=>以太网首部



传输控制协议TCP简介：

1. 面向连接的、可靠的、基于字节流的传输层通信协议
2. 将应用层的数据流分割成报文段并发送给目标节点的TCP层
3. 数据包都有序号，对方收到则发送ACK确认，未收到就重传
4. 使用校验来检验数据在传输过程中是否有误。



osi的实现：TCP/IP，并不完全符合OSI的7层参考模型

TCP/IP可以作为协议群的统称



TCP三次握手

TCP传输控制协议：

## TCP Flags：

1. URG：紧急指针
2. **ACK**：确认序号标志
3. PSH：push标志，表示该数据需要尽快传输给应用程序
4. RST:重置连接标志
5. **SYN**：同步序号，用于建立连接过程
6. **FIN**：finish标志，用于释放连接

三次握手：是为了初始化Sequence Number的初始值。

首次握手时的隐患---SYN超时：

​	针对SYN Flood的防护措施



建立连接之后，Client出现故障怎么办：

保活机制：

* 向对方发送保活探测报文，如果未收到响应则继续发送
* 尝试次数达到保活探测数仍未收到响应则中断连接



为什么会有TIME_WAIT状态：

* 确保有足够的时间让对方收到ACK包
* 避免新旧连接混淆

为什么需要四次握手才能断开：

* 因为全双工，发送方和接收方都需要FIN报文和ACK报文。

服务器出现大量的CLOSE_WAIT状态的原因：

* 对方关闭连接，我方忙于读写，没有及时关闭连接。



SYN 、ACK、Sequence

五次等待时间，完毕后中断，63秒断开

首次握手的隐患，SYN Flood

保活机制

四次挥手

TCP有20字节的报头信息



UDP简介：

UDP特点：

* 面向非连接
* 不维护连接状态，支持同时向多个客户端传输相同的消息
* 数据报头只有8个字节，额外开销比较小
* 吞吐量只受限于数据生成速率、传输速率以及机器的性能。
* 尽最大努力交付，不保证可靠交付，不需要维护复杂的连接状态
* 面向报文，不对应用程序提交的报文信息进行拆分或者合并。



**TCP和UDP的区别：**

面向连接vs无连接

TCP可靠

UDP会丢失

有序性

速度

量级



TCP滑动窗口：

RTT:发送一个数据包到收到对应ACK，所花的时间

ROT：重传时间间隔



**TCP使用滑动窗口做流量控制与乱序重排：**

* 保证TCP的可靠性
* 保证TCP的流控特性

确认重传机制

大小可以依据策略进行动态调整



### HTTP简介

* 支持客户、服务器模式
* 简单快速
* 灵活
* 无连接
* 无状态



请求/响应的步骤：

* 客户端连接到WEB服务器
* 发送HTTP请求
* 服务器接收请求并返回HTTP响应
* 释放TCP连接
* 客户端浏览器解析HTML内容



HTTP(超文本传输协议):

状态码：1xx、2xx、3xx、4xx、5xx

get、post的区别的三个层面：

1. HTTP报文层面：GET将请求信息放在url中，POST将请求信息放在报文体中
2. 数据库层面：GET符合幂等性和安全性，POST不符合
3. 其他层面：GET可以被缓存、被存储，而POST不行

get多用于查询

post用于添加

​	POST非幂等的，有副作用



cookie和session：

cookie：

jSESSION-id



# 关系型数据库主要考点

1. 架构
2. 索引
3. 锁
4. 语法
5. 理论范式



## 如何设计关系型数据库

1. 首先划分为两大部分
   1. 存储部分：类似于一个文件系统，将数据持久化到存储设备当中
   2. 程序实例模块对存储进行逻辑上的管理
2. 程序实例中涉及到：存储管理模块、缓存机制模块、SQL解析模块、日志管理模块、权限划分模块、容灾机制、索引管理(优化操作)、锁管理(支持并发操作)

## 索引模块:

1.为什么使用索引：

* 快速查询数据
* 避免全表扫描
* 提升检索效率

2.什么样的信息能成为索引

* 主键、唯一键、普通键等
* 能让数据具备一定区分性的字符串

3.索引的数据结构：

* 生成索引，建立二叉查找树进行二分查找
* 生成索引，建立B-Tree结构进行查找
* 生成索引，建立B+-Tree结构进行查找
* 生成索引，建立Hash结构进行查找、

4. 密集索引和稀疏索引：
   1. 密集索引文件中的每个搜索码值都对应一个索引值
   2. 稀疏索引文件值为索引码的，某些值建立索引项
5. 

## 二叉查找树上阵：

平衡二叉树：任意一个节点的左子树高度均不超过1

二叉树是具有缺点的，最坏情况下会造成线性树

树变矮一些效率会高一些

B-Tree：每个节点有多个孩子

B+Tree

Hash：不能用于范围查询。只满足=或者in

BitMap：位图索引.锁的力度非常大。不适合高并发



查看慢日志：将慢日志的状态设置为on状态

利用explain查看关键字段的具体类型：

type：

index、 all

extra：

Using filesort： 文件排序

using temporary：使用临时表

优化sql语句或者尽量让sql走索引：

用定义好的键取代非键值

给非索引值加上索引



密集索引比稀疏索引慢

走primarykey不一定是最快的，使用最合适的索引值

force（index）



## 联合索引的最左匹配原则

最左的索引是绝对有序的，而之后的值均是建立在最左的索引的顺序之上建立起来的，因此才形成了最左匹配原则。



索引是建立的越多越好吗：

* 数据量小的表不需要建立索引，建立会增加额外的索引开销
* 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
* 更多的索引意味着需要更多的空间



# MyISAM与InnoDB关于锁方面的区别是什么

* MysIAM默认使用的是表级锁，不支持行级锁
* InnoDB默认使用的是行级锁，同时也支持表级锁



当表进行查询的时候，MySIAM给表添加了一个表锁(会锁住整张表)，必须当该表中的查询语句执行完之后才能进行下一条语句的查询。

读锁、写锁

手动给表添加读锁：lock tables person_info_myisam read;

释放: unlock tables;

读锁也叫共享锁。进行范围查询时还是能够同时对表中的数据进行读操作。



写锁：update person_info_myisam set account=account where id in(1, 2000000);

上了写锁之后，就不可以上读锁，必须要等到写锁执行完毕之后才能进行读锁。

写锁之间不存在共享性。写锁是排他锁。

select 语句之后加上**for update**可以上**排它锁**。

MyISAM不支持事务，Mysql默认支持事务

* 总结：
  * mysiam默认支持表级锁，不支持行级锁
  * 锁按级别划分有两种：共享锁和排它锁

非阻塞select在innodb中得到支持

当前行加上共享锁之后，别的session就无法加上排他锁。加读共享锁的方法：**lock in share mode**

表级锁与索引无关。

在Innodb中不走索引的时候整张表就会被锁住

共享锁和排它锁的兼容性：

|      | X    | S    |
| ---- | ---- | ---- |
| X    | 冲突 | 冲突 |
| S    | 冲突 | 兼容 |

锁的粒度越细，付出的代价越高。

**乐观锁**：提交的时候再去检查版本是否正确，而不是提交之前就去查询版是否正确

**悲观锁**：在提交之前就去查询版本是否正确，唯有正确的版本才予以执行，比较耗费时间和资源





**数据库事务的四大特性：**

* ACID
  * 原子性(Automic):事务包含的所有操作，要么全部执行，要么全部失败
  * 一致性(Consistency)：数据库的数据量应该满足完整性约束
  * 隔离性(Isolation):一个事务与另一个事务是不相关的
  * 持久性(Durability)：一个事务如果提交成功，他应该被永久的保存在数据库中



**事务的隔离级别以及各级别下的并发访问问题：**

* 更新丢失
* 脏读 **read uncommited** 需要将事务设置为 **read commited**
* 









​	

